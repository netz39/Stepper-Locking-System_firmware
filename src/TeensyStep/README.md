# TeensyStep V2.1 - Fast Stepper Library for PJRC Teensy boards

Please note: This is version 2 of the library. This version has a new user interface. The version 1 is still available
in the branch [Version-1](https://github.com/luni64/TeensyStep/tree/Version-1).

## Detailed Documentation can be found here [https://luni64.github.io/TeensyStep/](https://luni64.github.io/TeensyStep/)

## Purpose of the Library

**TeensyStep** is an efficient Arduino library compatible with Teensy 3.0, 3.1, 3.2, 3.5, 3.6 and STM32F4. The library
is able to handle synchronous and independent movement and continuous rotation of steppers with pulse rates of up to
300'000 steps per second. The following table shows a summary of the **TeensyStep** specification:

| Description                                | Specification             | Default          |
|:-------------------------------------------|:-------------------------:|:----------------:|
| Motor speed / pulse rate                   |1 - 300'000 stp/s          |   800 stp/s      |
| Acceleration                               | 0 - 500'000 stp/s^2       |   2500 stp/s^2   |
| Pull in speed                              | 50-10'000 stp/s           | 100 stp/s |
| Synchronous movement of motors             | up to 10                  | -                |
| Independent movement of motors             | 4 groups of 1 to 10 motors| -                |
| Settable step pulse polarity               | Active HIGH or LOW        | Active HIGH      |
| Settable step pulse width                  | 1-100µs                   | 5µs              |
| Settable direction signal polarity         | cw / ccw                  | cw               |

Here a quick demonstration video showing two motors running in sync with 160'000 steps/sec

<a href="http://www.youtube.com/watch?feature=player_embedded&v=Fzt75I_Zi14
" target="_blank"><img src="http://img.youtube.com/vi/Fzt75I_Zi14/0.jpg"
alt="IMAGE ALT TEXT HERE" width="600" height="450" border="10" /></a>

# Adoption for OttoCar stepper steering system

## HAL Port

The `hal_port` folder contains all the files needed to compile the Arduino targeted TeensyStep library for STM32. To
code was mostly copied from [Arduino_Core_STM32](https://github.com/stm32duino/Arduino_Core_STM32) and adopted where
needed.

## How to support a new chip

Currently, it is only possible to support other chips from the STM32F1xx series. By adding the `*_ll_tim.h` headers for
other STM32 series, it should also be possible to support them.

#### Add CPPFLAGS
Make sure to add `CPPFLAGS` to the `include.mk` , to specify the chip you are using. 

```
CPPFLAGS = \
-DSTM32F103xB	\
-DSTM32F1xx	
```
#### Check time base source

Go to `stm32f1xx_hal_timebase_tim.c`, in `HAL_InitTick()` check, which timer is configured as time base source.

#### Add available Timers

Add a section with all available timers for your specific Chip in `TimerField.cpp`. Do **NOT** add the timer, used
as time base source. If you are using UAVCAN, also leave out the specified for use with UAVCAN. In Makefile projects, it
is the one specified in the upmost `Makefile` in the variable `UAVCAN_STM32_TIMER_NUMBER`.

#### Specify max timers and includes

Add a section to `TimerField.h` in `stm32`, specifying the header for the new chip and its `MAX_TIMERS`. Thi should match the
number of timers in the `Timerfield.cpp`. See the section under `STM32F103xB` for reference.

#### Adopt Interrupts

Go to `HardwareTimer.cpp` and scroll all the way down to the `TIMx IRQ Handler` section. Depending on your chip and the
number of available timers, multiple `IRQHandlers` will be added by via the `#ifdefs`. 

Make sure, to somehow remove the
ones, which are used by UAVCAN and the time base source. E.g. comment them, or put `#ifdefs`.

#### Adopt Callbacks

In `main.c` go to `HAL_TIM_PeriodElapsedCallback()`. Here you will see a callback generated by CubeMX, which increments
the tick. This is the same callback, which is used by our TeensyStep timers.

This means we have to redirect the call to call our `HardwareTimerCallbacks`. We therefore include our `CFunctions.h`
header, which declares a `hardwareTimerUpdateCallbackWrapper()`. This function is then defined in `HardwareTimer.cpp`
and calls `updateCallback()`.

```c
void hardwareTimerUpdateCallbackWrapper(TIM_HandleTypeDef *htim)
{
    HardwareTimer::updateCallback(htim);
}
```
The redirect in `main.c` looks like this:

```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM2) {
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */
  else {
    hardwareTimerUpdateCallbackWrapper(htim);
  }
  /* USER CODE END Callback 1 */
}
``` 

#### Define the PINS

In `Port.h` add a `#ifdef` section for your chip and define the pins you will you to control the stepper. These pins also need to be added to `pinToGPIOPinNumber()` and `pinToGPIOBase()` in `Port.cpp`
